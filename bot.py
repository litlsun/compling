# -*- coding: utf-8 -*-
"""bot

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DjpXm46UYskYCen715vDTEwXEcWqIKFm
"""

!pip install aiogram -q

pip install aiogram==3.0

# Устанавливаем необходимые библиотеки
!pip install aiogram requests scikit-learn gensim numpy

import logging
import requests
import numpy as np
from aiogram import Bot, Dispatcher, types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, ContentType
from aiogram.filters import Command
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from gensim.models import Word2Vec
from io import BytesIO
import json

# Загружаем данные из файла faq.json в переменную data
with open('faq.json', encoding='utf-8') as f:
    data = json.load(f)

# Токен API
API_TOKEN = "API-токен"

# Инициализация бота и диспетчера
logging.basicConfig(level=logging.INFO)
bot = Bot(token=API_TOKEN)
dp = Dispatcher()

# Создаём списки вопросов и ответов из переменной data
faq_questions = [item['question'] for item in data['faq']]
faq_answers = [item['answer'] for item in data['faq']]

# Инициализация TF-IDF
vectorizer = TfidfVectorizer()
tfidf_matrix = vectorizer.fit_transform(faq_questions)

# Инициализация модели Word2Vec
word2vec_model = Word2Vec(sentences=[q.split() for q in faq_questions], vector_size=100, window=5, min_count=1, workers=4)

# Кнопки для клавиатуры
kb = [
    [
        KeyboardButton(text="О компании"),  # Кнопка для запроса информации о компании
        KeyboardButton(text="Пожаловаться")  # Кнопка для подачи жалобы
    ]
]

keyboard = ReplyKeyboardMarkup(
    keyboard=kb,
    resize_keyboard=True,  # Уменьшаем клавиатуру под размер экрана
    input_field_placeholder="Выберите действие"  # Текст-подсказка
)

# Обрабатываем команду /start
@dp.message(Command("start"))
async def send_welcome(message: types.Message):
    await message.answer("С чем вам помочь?", reply_markup=keyboard)  # Отправляем сообщение с клавиатурой

# Обрабатываем нажатие кнопки "О компании"
@dp.message(lambda message: message.text == "О компании")
async def about_company(message: types.Message):
    await message.answer("Наша компания занимается доставкой товаров по всей стране.")

# Обрабатываем нажатие кнопки "Пожаловаться"
@dp.message(lambda message: message.text == "Пожаловаться")
async def complain(message: types.Message):
    await message.answer("Пожалуйста, отправьте изображение для подачи жалобы.")
    # Метод для обработки картинок
@dp.message(lambda message: message.content_type == ContentType.PHOTO)
async def handle_complaint_image(message: types.Message):
    try:
        # Логируем срабатывание обработчика
        logging.info("Обработчик фотографий сработал!")

        # Получаем информацию о файле
        file_id = message.photo[-1].file_id  # Берем самое большое изображение
        file = await bot.get_file(file_id)
        file_name = file.file_path.split("/")[-1]  # Извлекаем имя файла
        file_size = file.file_size  # Получаем размер файла

        # Логируем информацию о файле
        logging.info(f"Файл получен: {file_name}, размер: {file_size} байт")

        # Загрузка изображения (можно будет сохранить файл, если потребуется)
        file_url = f"https://api.telegram.org/file/bot{API_TOKEN}/{file.file_path}"
        image = BytesIO(requests.get(file_url).content)

        # Отправка информации о файле
        await message.answer(
            f"Ваш файл: {file_name}\n"
            f"Размер: {file_size} байт\n"
            "Ваш запрос передан специалисту."
        )
    except Exception as e:
        # Логируем ошибку, если что-то пошло не так
        logging.error(f"Ошибка при обработке фотографии: {e}")
        await message.answer("Произошла ошибка при обработке вашего запроса. Пожалуйста, попробуйте ещё раз.")


# Вычисление косинусного сходства для TF-IDF
def get_tfidf_answer(query):
    query_vec = vectorizer.transform([query])  # Преобразуем запрос в вектор
    similarities = cosine_similarity(query_vec, tfidf_matrix)
    best_match_idx = similarities.argmax()  # Ищем индекс наиболее похожего вопроса
    return faq_answers[best_match_idx]

# Вычисление косинусного сходства для Word2Vec
def get_word2vec_answer(query):
    def sentence_vector(sentence, model):
        words = sentence.split()
        vectors = [model.wv[word] for word in words if word in model.wv]
        return np.mean(vectors, axis=0) if vectors else np.zeros(model.vector_size)

    query_vec = sentence_vector(query, word2vec_model)
    faq_vectors = np.array([sentence_vector(q, word2vec_model) for q in faq_questions])
    similarities = cosine_similarity([query_vec], faq_vectors)
    best_match_idx = similarities.argmax()  # Ищем индекс наиболее похожего вопроса
    return faq_answers[best_match_idx]

# Обрабатываем все остальные сообщения
@dp.message()
async def answer_faq(message: types.Message):
    text = message.text  # Получаем текст сообщения от пользователя

    # Пробуем найти ответ с помощью TF-IDF
    tfidf_response = get_tfidf_answer(text)

    # Пробуем найти ответ с помощью Word2Vec
    word2vec_response = get_word2vec_answer(text)

    # Отправляем ответ пользователю
    await message.answer(f"Ответ на основе TF-IDF: {tfidf_response}\n\nОтвет на основе Word2Vec: {word2vec_response}")

# Запуск бота
async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    import asyncio

    # Проверяем, запущен ли уже цикл событий
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

    # Запускаем бота
    if loop.is_running():
        # Если цикл уже запущен, используем create_task
        loop.create_task(main())
    else:
        # Если цикл не запущен, используем run_until_complete
        loop.run_until_complete(main())